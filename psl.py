# Title:	Python Crypto Library
# Author:	Matthias Konrath
# Email:	office@inet-sec.at

"""
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
"""

# Description:
#	Python libary for encryption:
#	-) Diffie Hellam - key exchange
#	-) Encryption classes for AES, Blowfish, CAST, DES, 3DES, RC2, RC4 and AES - Blowfish - 3DES
#	-) File encryption with all above provided encryption classes
#	-) RSA - signing and encryption class
#	-) Base AES encrytpion socket clas
#	-) Diffie Hellman & AES encrypted server - client connection

#	-) RSA & AES encrypted server - client connection
#		(client only needs to konw the servers public key)
#	Decription:
#		The client sends the with RSA encrypted AES key to the server and
#		establishes an secure AES connection.

#	-) RSA & AES encrypted server - client connection with authentication
#		(server and client need to know each others public key)
#	Description:
#		In this configuration is at first an secure RSA connection established
#		and after this the AES key is generated by both parties and XOR'ed with
#		the AES key from the partner. The result of the XOR is the used for the AES
#		encryption.

#	-) RSA, AES & DH encrypted server - client connection with authentication
#		(server and client need to know each others public key)
#	Description:
#		Most secure configuration, this is because of the secure key exchange.
#		At first an RSA connection is established, after that an Diffie Hellman
#		key is exchanged and with this DH key the AES encryption is established.

# Encoding
import base64
from base64 import b64decode
from base64 import b64encode
from binascii import hexlify # For debug output

# Hash generation and password input
import hashlib
from Crypto.Hash import SHA512
import getpass

# Random number generator
from Crypto import Random
try:
	import ssl
	random_function = ssl.RAND_bytes
	random_provider = "Python SSL"
except (AttributeError, ImportError):
	import OpenSSL
	random_function = OpenSSL.rand.bytes
	random_provider = "OpenSSL"

# Encryption Classes
from Crypto.Cipher import AES
from Crypto.Cipher import Blowfish
from Crypto.Cipher import CAST
from Crypto.Cipher import DES
from Crypto.Cipher import DES3
from Crypto.Cipher import ARC2
from Crypto.Cipher import ARC4
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import PKCS1_v1_5

# Socket - client - server - connection
import socket

# System
import os
import os.path
import sys
import time

# Threading
from threading import Thread
from thread import start_new_thread, allocate_lock



#############################################################################################
###							Diffie Hellman Key exchange                                	  ###
#############################################################################################

class DiffieHellman(object):
	"""
	A reference implementation of the Diffie-Hellman protocol.
	By default, this class uses the 6144-bit MODP Group (Group 17) from RFC 3526.
	This prime is sufficient to generate an AES 256 key when used with
	a 540+ bit exponent.
	"""

	# Generate the public and private keys.
	# Input:	Generator number
	# Input:	Group
	# Input:	Keylength
	# Return:	-
	def __init__(self, generator=2, group=17, keyLength=540):
		try:
			min_keyLength = 180
			default_keyLength = 540

			default_generator = 2
			valid_generators = [ 2, 3, 5, 7 ]

			# Sanity check fors generator and keyLength
			if(generator not in valid_generators):
				print("Error: Invalid generator. Using default.")
				self.generator = default_generator
			else:
				self.generator = generator

			if(keyLength < min_keyLength):
				print("Error: keyLength is too small. Setting to minimum.")
				self.keyLength = min_keyLength
			else:
				self.keyLength = keyLength

			self.prime = self.getPrime(group)

			self.privateKey = self.genPrivateKey(keyLength)
			self.publicKey = self.genPublicKey()
		except Exception as e:
			print "[+] Failed to initialize Diffie Hellman!"
			print "[-]", e

	# Given a group number, return a prime.
	# Input:	Group number
	# Return:	Prime number
	def getPrime(self, group):
		try:
			default_group = 17

			primes = {
			5:  0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF,
			14: 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AACAA68FFFFFFFFFFFFFFFF,
			15: 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF,
			16: 0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C934063199FFFFFFFFFFFFFFFF,
			17:
			0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C93402849236C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AACC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E6DCC4024FFFFFFFFFFFFFFFF,
			18:
			0xFFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A92108011A723C12A787E6D788719A10BDBA5B2699C327186AF4E23C1A946834B6150BDA2583E9CA2AD44CE8DBBBC2DB04DE8EF92E8EFC141FBECAA6287C59474E6BC05D99B2964FA090C3A2233BA186515BE7ED1F612970CEE2D7AFB81BDD762170481CD0069127D5B05AA993B4EA988D8FDDC186FFB7DC90A6C08F4DF435C93402849236C3FAB4D27C7026C1D4DCB2602646DEC9751E763DBA37BDF8FF9406AD9E530EE5DB382F413001AEB06A53ED9027D831179727B0865A8918DA3EDBEBCF9B14ED44CE6CBACED4BB1BDB7F1447E6CC254B332051512BD7AF426FB8F401378CD2BF5983CA01C64B92ECF032EA15D1721D03F482D7CE6E74FEF6D55E702F46980C82B5A84031900B1C9E59E7C97FBEC7E8F323A97A7E36CC88BE0F1D45B7FF585AC54BD407B22B4154AACC8F6D7EBF48E1D814CC5ED20F8037E0A79715EEF29BE32806A1D58BB7C5DA76F550AA3D8A1FBFF0EB19CCB1A313D55CDA56C9EC2EF29632387FE8D76E3C0468043E8F663F4860EE12BF2D5B0B7474D6E694F91E6DBE115974A3926F12FEE5E438777CB6A932DF8CD8BEC4D073B931BA3BC832B68D9DD300741FA7BF8AFC47ED2576F6936BA424663AAB639C5AE4F5683423B4742BF1C978238F16CBE39D652DE3FDB8BEFC848AD922222E04A4037C0713EB57A81A23F0C73473FC646CEA306B4BCBC8862F8385DDFA9D4B7FA2C087E879683303ED5BDD3A062B3CF5B3A278A66D2A13F83F44F82DDF310EE074AB6A364597E899A0255DC164F31CC50846851DF9AB48195DED7EA1B1D510BD7EE74D73FAF36BC31ECFA268359046F4EB879F924009438B481C6CD7889A002ED5EE382BC9190DA6FC026E479558E4475677E9AA9E3050E2765694DFC81F56E880B96E7160C980DD98EDD3DFFFFFFFFFFFFFFFFF
			}

			if group in primes.keys():
				return primes[group]
			else:
				print("Error: No prime with group %i. Using default." % group)
				return primes[default_group]

		except Exception as e:
			print "[+] Failed to return a prime number!"
			print "[-]", e

	# Generate a random number with the specified number of bits
	# Input:	Size in bits of the random number
	# Return:	Random key
	def genRandom(self, bits):
		try:
			_rand = 0
			_bytes = bits // 8 + 8

			while(_rand.bit_length() < bits):
				try:
					# Python 3
					_rand = int.from_bytes(random_function(_bytes), byteorder='big')
				except:
					# Python 2
					_rand = int(OpenSSL.rand.bytes(_bytes).encode('hex'), 16)

			return _rand
		except Exception as e:
			print "[+] Failed to generate random numbers!"
			print "[-]", e

	# Generate a private key using a secure random number generator.
	# Input:	Size of the private key (in bit)
	# Return:	Random personal public key
	def genPrivateKey(self, bits):
		try:
			return self.genRandom(bits)
		except Exception as e:
			print "[+] Failed to generate private key!"
			print "[-]", e

	# Generate a public key X with g**x % p.
	# Input:	-
	# Return:	Personal public key
	def genPublicKey(self):
		try:
			return pow(self.generator, self.privateKey, self.prime)
		except Exception as e:
			print "[+] Failed to generate public key!"
			print "[-]", e

	# Check the other party's public key to make sure it's valid.
	# Since a safe prime is used, verify that the Legendre symbol == 1
	# Input:	Partners key
	# Return:	True or False
	def checkPublicKey(self, otherKey):
		try:
			if(otherKey > 2 and otherKey < self.prime - 1):
				if(pow(otherKey, (self.prime - 1)//2, self.prime) == 1):
					return True
			return False
		except Exception as e:
			print "[+] Failed to other part's public key!"
			print "[-]", e

	# Check to make sure the public key is valid.
	# Then combine it with the private key to generate a shared secret.
	# Input:	Private key and partners key
	# Return:	Shared secret key
	def genSecret(self, privateKey, otherKey):
		try:
			if(self.checkPublicKey(otherKey) == True):
				sharedSecret = pow(otherKey, privateKey, self.prime)
				return sharedSecret
			else:
				raise Exception("Invalid public key.")
		except Exception as e:
			print "[+] Failed no valid public key from the partner!"
			print "[-]", e

	# Derive the shared secret, then hash it to obtain the shared key.
	# Input:	Partners key
	# Return:	-
	def genKey(self, otherKey):
		try:
			self.sharedSecret = self.genSecret(self.privateKey, otherKey)

			# Convert the shared secret (int) to an array of bytes in network order
			# Otherwise hashlib can't hash it.
			try:
				_sharedSecretBytes = self.sharedSecret.to_bytes(
					self.sharedSecret.bit_length() // 8 + 1, byteorder="big")
			except AttributeError:
				_sharedSecretBytes = str(self.sharedSecret)

			s = hashlib.sha256()
			s.update(bytes(_sharedSecretBytes))
			self.key = s.digest()
		except Exception as e:
			print "[+] Failed to generate shared secret!"
			print "[-]", e

	# Return the shared secret key
	# Input:	-
	# Return:	Shared secret key (256 bit)
	def getKey(self):
		try:
			return self.key
		except Exception as e:
			print "[+] Failed to return shared secret key!"
			print "[-]", e

#############################################################################################
###							Diffie Hellman Key exchange                                	  ###
#############################################################################################


#############################################################################################
###									AES Encryption                        	           	  ###
#############################################################################################

# Needed functions and parameters (for AES, Blowfish, CAST, DES, 3DES & RC2)
BS = 16
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)
unpad = lambda s : s[:-ord(s[len(s)-1:])]

# AES 256 bit CBC encryption class
class AESCipher(object):

	# Constructor which is initialized with the 256 bit key
	# Input:	Password (128, 192 or 256 bit)
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Key calculation
		if len(key) == 32:
			self.key = key
		else:
			self.key = hashlib.sha512(key).digest()[:32]

		# Setting block size
		self.block_size = AES.block_size

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datablock
	# Return:	Encrypted datablock
	def encrypt(self, raw):
		try:
			# Create padding from the input
			raw = pad(raw)

			# Generate random iv
			iv = Random.new().read(self.block_size)

			# Generate encryption key
			cipher = AES.new(self.key, AES.MODE_CBC, iv)

			# Encrypt the data and return it encoded
			return base64.urlsafe_b64encode(iv + cipher.encrypt(raw))
		except Exception as e:
			print "[+] Failed to encrypt with AES!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, enc):
		try:
			# Decode raw encrypted data
			enc = base64.urlsafe_b64decode(enc.encode('utf-8'))

			# Retrieve iv from first block
			iv = enc[:self.block_size]

			# Generate decryption key
			cipher = AES.new(self.key, AES.MODE_CBC, iv)

			# Decrypt the data and return it
			return unpad(cipher.decrypt(enc[self.block_size:]))
		except Exception as e:
			print "[+] Failed to decrypt with AES!"
			print "[-]", e

#############################################################################################
###									AES Encryption                        	           	  ###
#############################################################################################


#############################################################################################
###									Blowfish Encryption                    	           	  ###
#############################################################################################

# Blowfish 448 bit CBC encryption class
class BLOWFISHCipher(object):

	# Constructor which is initialized with the 448 bit key
	# Input:	Password (448 bit or below) if it is less then 448 it get hashed
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Key calculation
		if len(key) == 56:
			self.key = key
		else:
			self.key = hashlib.sha512(key).digest()[:56]

		# Setting block size
		self.block_size = 8

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datablock
	# Return:	Encrypted datablock
	def encrypt(self, raw):
		try:
			# Create padding from the input
			raw = pad(raw)

			# Generate random iv
			iv = Random.new().read(self.block_size)

			# Generate encryption key
			cipher = Blowfish.new(self.key, Blowfish.MODE_CBC, iv)

			# Encrypt the data and return it encoded
			return base64.urlsafe_b64encode(iv + cipher.encrypt(raw))
		except Exception as e:
			print "[+] Failed to encrypt with Blowfish!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, enc):
		try:
			# Decode raw encrypted data
			enc = base64.urlsafe_b64decode(enc.encode('utf-8'))

			# Retrieve iv from first block
			iv = enc[:self.block_size]

			# Generate decryption key
			cipher = Blowfish.new(self.key, Blowfish.MODE_CBC, iv)

			# Decrypt the data and return it
			return unpad(cipher.decrypt(enc[self.block_size:]))
		except Exception as e:
			print "[+] Failed to decrypt with Blowfish!"
			print "[-]", e

#############################################################################################
###									Blowfish Encryption                    	           	  ###
#############################################################################################


#############################################################################################
###										CAST Encryption                    	           	  ###
#############################################################################################

# CAST 128 bit CBC encryption class
class CASTCipher(object):

	# Constructor which is initialized with the 128 bit key
	# Input:	Password (128 bit or below) if it is less then 128 it get hashed
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Key calculation
		if len(key) == 16:
			self.key = key
		else:
			self.key = hashlib.sha512(key).digest()[:16]

		# Setting block size
		self.block_size = 8

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datablock
	# Return:	Encrypted datablock
	def encrypt(self, raw):
		try:
			# Create padding from the input
			raw = pad(raw)

			# Generate random iv
			iv = Random.new().read(self.block_size)

			# Generate encryption key
			cipher = CAST.new(self.key, CAST.MODE_CBC, iv)

			# Encrypt the data and return it encoded
			return base64.urlsafe_b64encode(iv + cipher.encrypt(raw))
		except Exception as e:
			print "[+] Failed to encrypt with CAST!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, enc):
		try:
			# Decode raw encrypted data
			enc = base64.urlsafe_b64decode(enc.encode('utf-8'))

			# Retrieve iv from first block
			iv = enc[:self.block_size]

			# Generate decryption key
			cipher = CAST.new(self.key, CAST.MODE_CBC, iv)

			# Decrypt the data and return it
			return unpad(cipher.decrypt(enc[self.block_size:]))
		except Exception as e:
			print "[+] Failed to decrypt with CAST!"
			print "[-]", e

#############################################################################################
###										CAST Encryption                    	           	  ###
#############################################################################################



#############################################################################################
###										DES Encryption                    	           	  ###
#############################################################################################

# DES CBC encryption class
class DESCipher(object):

	# Constructor which is initialized with the key
	# Input:	Password (64 bit or below) if it is less then 64 bit it get hashed (real keysize is only 56 bit)
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Key calculation
		if len(key) == 8:
			self.key = key
		else:
			self.key = hashlib.sha512(key).digest()[:8]

		# Setting block size
		self.block_size = 8

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datablock
	# Return:	Encrypted datablock
	def encrypt(self, raw):
		try:
			# Create padding from the input
			raw = pad(raw)

			# Generate random iv
			iv = Random.new().read(self.block_size)

			# Generate encryption key
			cipher = DES.new(self.key, DES.MODE_CBC, iv)

			# Encrypt the data and return it encoded
			return base64.urlsafe_b64encode(iv + cipher.encrypt(raw))
		except Exception as e:
			print "[+] Failed to encrypt with DES!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, enc):
		try:
			# Decode raw encrypted data
			enc = base64.urlsafe_b64decode(enc.encode('utf-8'))

			# Retrieve iv from first block
			iv = enc[:self.block_size]

			# Generate decryption key
			cipher = DES.new(self.key, DES.MODE_CBC, iv)

			# Decrypt the data and return it
			return unpad(cipher.decrypt(enc[self.block_size:]))
		except Exception as e:
			print "[+] Failed to decrypt with DES!"
			print "[-]", e

#############################################################################################
###										DES Encryption                    	           	  ###
#############################################################################################


#############################################################################################
###										3DES Encryption                    	           	  ###
#############################################################################################

# 3DES CBC encryption class
class DES3Cipher(object):

	# Constructor which is initialized with the key
	# Input:	Password  if it is less then 192 bit it get hashed
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Key calculation
		if len(key) == 24:
			self.key = key
		else:
			self.key = hashlib.sha512(key).digest()[:24]

		# Setting block size
		self.block_size = 8

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datablock
	# Return:	Encrypted datablock
	def encrypt(self, raw):
		try:
			# Create padding from the input
			raw = pad(raw)

			# Generate random iv
			iv = Random.new().read(self.block_size)

			# Generate encryption key
			cipher = DES3.new(self.key, DES3.MODE_CBC, iv)

			# Encrypt the data and return it encoded
			return base64.urlsafe_b64encode(iv + cipher.encrypt(raw))
		except Exception as e:
			print "[+] Failed to encrypt with 3DES!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, enc):
		try:
			# Decode raw encrypted data
			enc = base64.urlsafe_b64decode(enc.encode('utf-8'))

			# Retrieve iv from first block
			iv = enc[:self.block_size]

			# Generate decryption key
			cipher = DES3.new(self.key, DES3.MODE_CBC, iv)

			# Decrypt the data and return it
			return unpad(cipher.decrypt(enc[self.block_size:]))
		except Exception as e:
			print "[+] Failed to decrypt with 3DES!"
			print "[-]", e

#############################################################################################
###										3DES Encryption                    	           	  ###
#############################################################################################


#############################################################################################
###									RC2 Encryption                        	           	  ###
#############################################################################################

# RC4 encryption class
class RC2Cipher(object):

	# Constructor which is initialized with the Password for the encryption
	# Input:	Password
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Secret password to hash with the random number (the larger the better)
		self.key = key
		# Blocksize of the random number (higher is better)
		self.RC4_BS = 8

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datablock
	# Return:	Encrypted datablock
	def encrypt(self, raw):
		try:
			# Create padding from the input
			raw = pad(raw)

			# Generate random iv
			iv = Random.new().read(self.RC4_BS)

			# Generate RC4 key for the datastream
			cipher = ARC2.new(self.key, ARC2.MODE_CBC, iv)

			# Encrypt the data and return it encoded
			return base64.urlsafe_b64encode(iv + cipher.encrypt(raw))
		except Exception as e:
			print "[+] Failed to encrypt with RC2!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, enc):
		try:
			# Decode raw encrypted data
			enc = base64.urlsafe_b64decode(enc.encode('utf-8'))
			# Retrieve iv from first block
			iv = enc[:self.RC4_BS]

			# Generate RC4 key for the datastream
			cipher = ARC2.new(self.key, ARC2.MODE_CBC, iv)

			# Decrypt, decode and return the given data
			return unpad(cipher.decrypt(enc[self.RC4_BS:]))
		except Exception as e:
			print "[+] Failed to decrypt with RC2!"
			print "[-]", e

#############################################################################################
###									RC2 Encryption                        	           	  ###
#############################################################################################


#############################################################################################
###									RC4 Encryption                        	           	  ###
#############################################################################################

# RC4 encryption class
class RC4Cipher(object):

	# Constructor which is initialized with the Password for the encryption
	# Input:	Password
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Secret password to hash with the random number (the larger the better)
		self.key = key
		# Blocksize of the random number (higher is better)
		self.RC4_BS = 32

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datastream
	# Return:	Encrypted datastream
	def encrypt(self, raw):
		try:
			# Generate random iv
			iv = Random.new().read(self.RC4_BS)

			# Generate RC4 key for the datastream
			tmp_key = hashlib.sha512(self.key + iv).digest()
			cipher = ARC4.new(tmp_key)

			# Encrypt the data and return it encoded
			return base64.urlsafe_b64encode(iv + cipher.encrypt(raw))
		except Exception as e:
			print "[+] Failed to encrypt with RC4!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datastream
	# Return:	Decrypted datastream
	def decrypt(self, enc):
		try:
			# Decode raw encrypted data
			enc = base64.urlsafe_b64decode(enc.encode('utf-8'))
			# Retrieve iv from first block
			iv = enc[:self.RC4_BS]

			# Generate RC4 key for the datastream
			tmp_key = hashlib.sha512(self.key + iv).digest()
			cipher = ARC4.new(tmp_key)

			# Decrypt, decode and return the given data
			return cipher.decrypt(enc[self.RC4_BS:])
		except Exception as e:
			print "[+] Failed to decrypt with RC4!"
			print "[-]", e

#############################################################################################
###									RC4 Encryption                        	           	  ###
#############################################################################################


#############################################################################################
###							AES - Blowfish - 3DES Encryption               	           	  ###
#############################################################################################

class AES_Blowfish_3DES(object):

	# Constructor which is initialized with the Password for the encryption
	# Input:	Password
	# Return:	-
	def __init__(self, key=""):
		# Check if password was provided
		if key == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)
			else:
				key = password0

		# Secret password to hash with the random number (the larger the better)
		password_hash = hashlib.sha512(key).digest()

		self.aes_key = password_hash[0:256]
		self.blowfish_key = password_hash[256:384]
		self.des3_key = password_hash[384:512]

	# Encrypt raw input data with the key given earlier
	# Input:	Cleartext datablock
	# Return:	Encrypted datablock
	def encrypt(self, raw):
		try:

			AES_ENC = AESCipher(self.aes_key)
			BLOWFISH_ENC = BLOWFISHCipher(self.blowfish_key)
			DES3_ENC = DES3Cipher(self.des3_key)

			DES3_BLOCK = DES3_ENC.encrypt(raw)
			BLOWFISH_BLOCK = BLOWFISH_ENC.encrypt(DES3_BLOCK)
			AES_BLOCK = AES_ENC.encrypt(BLOWFISH_BLOCK)


			return AES_BLOCK
		except Exception as e:
			print "[+] Failed to encrypt with RC4!"
			print "[-]", e

	# Decrypt raw input data with the key given earlier
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, enc):
		try:
			AES_ENC = AESCipher(self.aes_key)
			AES_ENC = BLOWFISHCipher(self.blowfish_key)
			DES3_ENC = DES3Cipher(self.des3_key)

			AES_BLOCK = AES_ENC.decrypt(enc)
			BLOWFISH_BLOCK = BLOWFISH_ENC.decrypt(AES_BLOCK)
			DES3_BLOCK = DES3_ENC.decrypt(BLOWFISH_BLOCK)


			return DES3_BLOCK
		except Exception as e:
			print "[+] Failed to decrypt with RC4!"
			print "[-]", e

#############################################################################################
###							AES - Blowfish - 3DES Encryption               	           	  ###
#############################################################################################


#############################################################################################
###									 Encrypted files		      				       	  ###
#############################################################################################

# Used for encryption files
class ENC_FILE(object):

	# Initiate encryption
	# Input:	Password to hash with SHA512
	# Input:	Encryption algorithm (AES, Blowfish, CAST, ...)
	# Return:	-
	def __init__(self, encryption_type, password=""):
		try:
			# Get user password for encryption
			if password == "":
				password0 = getpass.getpass("Password for the encryption of the private key: ")
				password1 = getpass.getpass("Please enter the password again: ")

				if password0 != password1:
					print "[+] Not the same Passwords!"
					exit(1)
				else:
					password = password0

			if encryption_type == "AES":
				self.encryption = AESCipher(password)
			elif encryption_type == "BLOWFISH":
				self.encryption = BLOWFISHCipher(password)
			elif encryption_type == "CAST":
				self.encryption = CASTCipher(password)
			elif encryption_type == "DES":
				self.encryption = DESCipher(password)
			elif encryption_type == "3DES":
				self.encryption = DES3Cipher(password)
			elif encryption_type == "RC2":
				self.encryption = RC2Cipher(password)
			elif encryption_type == "RC4":
				self.encryption = RC4Cipher(password)
			elif encryption_type == "Tripple":
				self.encryption = AES_Blowfish_3DES(password)
			else:
				print "[+] Wrong encryption type!"
				exit(1)

			# File extension for encrypted files
			self.file_extention = ".enc_"
			self.file_extention += encryption_type

		except Exception as e:
			print "[+] Failed to set encryption password for file encryption!"
			print "[-]", e

	# Encrypt a given file with the earlier profided hashed key
	# Input:	Filename (and location)
	# Return:	-
	def encrypt_file(self, filename):
		try:
			# Read all cleartext data from the file
			cleartext_data = str (open(filename, "rb").read())

			# Encrypt the cleartext data
			encrypted_data = self.encryption.encrypt(cleartext_data)

			# Store the encrypted data in a file
			new_filename = filename
			new_filename += self.file_extention
			open(new_filename, "wb").write(encrypted_data)
		except Exception as e:
			print "[+] Failed to encrypt file!"
			print "[-]", e

	# Decrypt a given file with the earlier profided hashed key
	# Input:	Filename (and location)
	# Return:	-
	def decrypt_file(self, filename):
		try:
			# Read all encrypted data from file
			encrypted_data = str (open(filename, "rb").read())

			# Decrypt all data
			decrypted_data = self.encryption.decrypt(encrypted_data)

			# Store the decrypted data in a file
			new_filename = filename[:-len(self.file_extention)]
			open(new_filename, "wb").write(decrypted_data)
		except Exception as e:
			print "[+] Failed to decrypt file!"
			print "[-]", e

#############################################################################################
###									 Encrypted files		      				       	  ###
#############################################################################################


#############################################################################################
###								RSA Class - Encryption	       	   	     				  ###
#############################################################################################

# RSA class used for encryption and signing of data and files
class RSA_ENC(object):

	# Generate a new RSA private key
	# Input:	Keysize (1024, 2048 or 4096)
	# Return:	-
	def generate_new_key(self, keysize=4069):
		try:
			if keysize != 1024 and keysize != 2048 and keysize != 4096:
				print "Wrong keysize!"
				print "Please chose either 1024, 2048 or 4096 bit key!"
				exit(1)

			# Gernerate RSA - Key
			random_generator = Random.new().read
			self.rsa_key = RSA.generate(keysize, random_generator)

		except Exception as e:
			print "[+] Failed to generate RSA key!"
			print "[-]", e

	# Import a RSA key from a file (public or private)
	# Input:	Filename (and location) of the key
	# Return:	-
	def import_key(self, key_loc, password=""):
		# Import RSA key
		try:
			# Test if RSA key is not encrypted and if so import the key
			raw_rsa_key = open(key_loc, "r").read()
		except:
			# If RSA key was not imported try to decrypt it with user key and try to import it
			if password == "":
				password = getpass.getpass("Password to unlock public key: ")

			# Get password for decryption and hash it with sha256
			password_hash = hashlib.sha512(password)

			# Decrypt RSA key
			enc_rsa_key = open(key_loc, "rb").read()
			aes_obj = AESCipher(password_hash.hexdigest()[:32])
			raw_rsa_key = aes_obj.decrypt(enc_rsa_key)

		self.rsa_key = RSA.importKey(raw_rsa_key)

	# Stores RSA key unencrypted in a file
	# Input:	Filename (and location) for the key
	# Return:	-
	def store_key(self, key_loc):
		open(key_loc, "wb").write(self.rsa_key.exportKey('PEM'))

	# Stores RSA key encrypted in a file (if password is empty the programm asks for it)
	# Input:	Filename (and location) for the key
	# Return:	-
	def store_key_encrypted(self, key_loc, password=""):
		if password == "":
			password0 = getpass.getpass("Password for the encryption of the private key: ")
			password1 = getpass.getpass("Please enter the password again: ")

			if password0 != password1:
				print "[+] Not the same Passwords!"
				exit(1)

		password_hash = hashlib.sha512(password)
		aes_obj = AESCipher(password_hash.hexdigest()[:32])
		encrypted_rsa_key = aes_obj.encrypt(self.rsa_key.exportKey('PEM'))

		open(key_loc, "wb").write(encrypted_rsa_key)

	# Stores RSA public key in a file
	# Input:	Filename (and location) for the key
	# Return:	-
	def store_public_key(self, key_loc):
		open(filename, "wb").write(self.rsa_key.publickey().exportKey('PEM'))

	# Encrypt a datablock with RSA (for small data)
	# Input:	Decrypted datablock
	# Return:	Encrypted datablock
	def encrypt(self, cleartext):
		try:
			# Import RSA key with PKCS1
			pkcs_rsa_key = PKCS1_OAEP.new(self.rsa_key)

			# Encrypt the cleartext with the RSA key and return it
			chiphertext = pkcs_rsa_key.encrypt(cleartext)
			return chiphertext.encode('base64')
		except Exception as e:
			print "[+] Failed to encrypt datablock with RSA!"
			print "[-]", e

	# Decrypt a datablock with RSA (for small data)
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt(self, chiphertext):
		try:
			# Import RSA key with PKCS1
			pkcs_rsa_key = PKCS1_OAEP.new(self.rsa_key)

			# Decrypt the chiphertext with RSA and return it
			cleartext = pkcs_rsa_key.decrypt(b64decode(chiphertext))
			return cleartext
		except Exception as e:
			print "[+] Failed to decrypt RSA datablock!"
			print "[-]", e

	# Encrypt a datablock with RSA and AES (for large data)
	# Input:	Decrypted datablock
	# Return:	Encrypted datablock
	def encrypt_aes(self, data):
		try:
			# Import RSA key with PKCS1
			pkcs_rsa_key = PKCS1_OAEP.new(self.rsa_key)

			# Generate random AES key and encrypt it with RSA
			aes_key = Random.new().read(32)
			encrypted_aes_key = pkcs_rsa_key.encrypt(aes_key)

			# Encrypt with the generated AES key
			aes_obj = AESCipher(aes_key)
			chiphertext = aes_obj.encrypt(data)

			# Append the with RSA encrypted AES key
			output_data = encrypted_aes_key.encode('base64')
			# Append 16 characters to be able to distinguish between encrypted AES key and encrypted file
			output_data += "X" * 16
			# Append the with AES encrypted data
			output_data += chiphertext

			# Return all encrypted data
			return output_data
		except Exception as e:
			print "[+] Failed to encrypt file with RSA - AES!"
			print "[-]", e

	# Decrypt a datablock with RSA and AES (for large data)
	# Input:	Encrypted datablock
	# Return:	Decrypted datablock
	def decrypt_aes(self, data):
		try:
			# Import RSA key with PKCS1
			pkcs_rsa_key = PKCS1_OAEP.new(self.rsa_key)

			# Search for the 16 X to distinguish between encrypted key and encrypted data
			after_key = "X" * 16
			key_size = data.find(after_key)
			# Decrypt AES key with RSA
			aes_key = pkcs_rsa_key.decrypt(b64decode(data[:key_size]))

			# Decrypt the AES encrypted data
			aes_obj = AESCipher(aes_key)
			cleartext = aes_obj.decrypt(data[key_size + len(after_key):])

			# Return the decrypted data
			return cleartext
		except Exception as e:
			print "[+] Failed to decrypt RSA - AES file!"
			print "[-]", e

	# Encrypt a file with RSA and AES
	# Input:	Filename (and location)
	# Return:	-
	def encrypt_file(self, filename):
		try:
			# Import RSA key with PKCS1
			pkcs_rsa_key = PKCS1_OAEP.new(self.rsa_key)

			# Generate random AES key and encrypt it with RSA
			aes_key = Random.new().read(32)
			encrypted_aes_key = pkcs_rsa_key.encrypt(aes_key)

			# Encrypt with the generated AES key the file
			aes_obj = AESCipher(aes_key)
			cleartext = open(filename, "rb").read()
			chiphertext = aes_obj.encrypt(cleartext)

			# Append the with RSA encrypted AES key to the output file
			output_file = encrypted_aes_key.encode('base64')
			# Append 16 characters to be able to distinguish between encrypted AES key and encrypted file
			output_file += "X" * 16
			# Append the with AES encrypted data
			output_file += chiphertext

			# Store all encrypted data
			rsa_aes_keyfile = filename
			rsa_aes_keyfile += ".rsa_aes"
			open(rsa_aes_keyfile, "wb").write(output_file)
		except Exception as e:
			print "[+] Failed to encrypt file with RSA - AES!"
			print "[-]", e

	# Decrypt a file with RSA and AES
	# Input:	Filename (and location)
	# Return:	-
	def decrypt_file(self, filename):
		try:
			# Import RSA key with PKCS1
			pkcs_rsa_key = PKCS1_OAEP.new(self.rsa_key)

			# Read all encrypted data
			rsa_aes_data = open(filename, "rb").read()

			# Search for the 16 X to distinguish between encrypted key and encrypted data
			after_key = "X" * 16
			key_size = rsa_aes_data.find(after_key)
			# Decrypt AES key with RSA
			aes_key = pkcs_rsa_key.decrypt(b64decode(rsa_aes_data[:key_size]))

			# Decrypt the AES encrypted file
			aes_obj = AESCipher(aes_key)
			cleartext = aes_obj.decrypt(rsa_aes_data[key_size + len(after_key):])

			# Store the decrypted file
			open(filename[:-len(".rsa_aes")], "wb").write(cleartext)
		except Exception as e:
			print "[+] Failed to decrypt RSA - AES file!"
			print "[-]", e

	# Sign a datablock with RSA and SHA512
	# Input:	Datablock
	# Return:	Signature
	def sign(self, data):
		try:
			# Import RSA key with PKCS1
			signer = PKCS1_v1_5.new(self.rsa_key)

			# Create sha512 hash from the data
			digest = SHA512.new()
			digest.update(b64encode(data))

			# Sign the sha512 hash with the private key and return it
			sign = signer.sign(digest)
			return b64encode(sign)

		except Exception as e:
			print "[+] Failed to sign data!"
			print "[-]", e

	# Verify a datablock with RSA and SHA512
	# Input:	Signature
	# Input:	Datablock
	# Return:	True or False
	def verify(self, signature, data):
		try:
			# Import RSA key with PKCS1
			signer = PKCS1_v1_5.new(self.rsa_key)

			# Create sha512 hash from the data
			digest = SHA512.new()
			digest.update(b64encode(data))

			# Compare the two signature
			if signer.verify(digest, b64decode(signature)):
				return True
			return False
		except Exception as e:
			print "[+] Failed to verify data!"
			print "[-]", e

	# Sign a file wit RSA and SHA512
	# Input:	Filename of the file to sign (and location)
	# Return:	-
	def sign_file(self, filename):
		try:
			# Import RSA key with PKCS1
			signer = PKCS1_v1_5.new(self.rsa_key)

			# Create sha512 hash from the data in the file
			digest = SHA512.new()
			data = open(filename, "rb").read()
			digest.update(b64encode(data))

			# Sign the sha512 hash with the private key
			sign = signer.sign(digest)

			# Store the encrypted hash in the signature file
			new_filename = filename
			new_filename += ".rsa_sig"
			open(new_filename, "wb").write(b64encode(sign))
		except Exception as e:
			print "[+] Failed to sign file!"
			print "[-]", e

	# Verify a file signature with RSA and SHA512
	# Input:	Filename of the file to check (and location)
	# Return:	True or False
	def verify_file(self, filename):
		try:
			# Import RSA key with PKCS1
			signer = PKCS1_v1_5.new(self.rsa_key)

			# Create sha512 hash from the data in the file
			digest = SHA512.new()
			data = open(filename, "rb").read()
			digest.update(b64encode(data))

			# Open and read the signture file
			signed_filename = filename
			signed_filename += ".rsa_sig"
			signature = open(signed_filename, "rb").read()

			# Compare the two signatures
			if signer.verify(digest, b64decode(signature)):
				return True
			return False

		except Exception as e:
			print "[+] Failed to verify singed file!"
			print "[-]", e

	# Shows the RSA private key
	# Input:	-
	# Return:	PEM encoded RSA private key
	def show_private_key(self):
		try:
			return self.rsa_key.exportKey('PEM')
		except Exception as e:
			print "[+] Could not return private key!"
			print "[-]", e

	# Shows the RSA public key
	# Input:	-
	# Return:	PEM encoded RSA public key
	def show_public_key(self):
		try:
			return self.rsa_key.publickey().exportKey('PEM')
		except Exception as e:
			print "[+] Could not return private key!"
			print "[-]", e

#############################################################################################
###								RSA Class - Encryption	       	   	     				  ###
#############################################################################################


#############################################################################################
###				 			Socket - Encryption - Base Class    	 			      	  ###
###									With a socket										  ###
#############################################################################################

# Class for an encrypted AES connection
# Uses an external socket
class base_aes_socket_encryption_class(object):

	# Initialize the class
	# Input:	Socket
	# Return:	-
	def __init__(self, sock):
		self.std_buffer = 4096
		self.socket = sock

	# Send data over encrypted socket
	# Input:	-
	# Return:	-
	def send(self, data_to_send):
		try:
			# Encrypt the data with AES
			encrypted_data = self.AES_encryption.encrypt(data_to_send)

			# Chose the socket to send the encrypted data
			self.socket.send(encrypted_data)

		except Exception as e:
			print "[+] Failed to send encrypted data!"
			print "[-]", e

	# Recive encrypted data over socket
	# Input:	Buffer size
	# Return:	-
	def recv(self, buffer_size=0):
		try:
			if buffer_size == 0:
				buffer_size = self.std_buffer

			encrypted_data = self.socket.recv(buffer_size)

			# Decrypt the data and return it
			decrypted_data = self.AES_encryption.decrypt(encrypted_data)
			return decrypted_data

		except Exception as e:
			print "[+] Failed to recive encrypted data!"
			print "[-]", e

	# Sends an encrypted aes file over socket
	# Input:	Filename (and location) from the file to send
	# Return:	-
	def send_file(self, path_to_file):
		try:
			# Read all data from the file and encrypt it
			data = open(path_to_file, "r").read()
			encrypted_data = self.AES_encryption.encrypt(data)

			self.socket.send(encrypted_data)
		except Exception as e:
			print "[+] Failed to send the encrypted file!"
			print "[-]", e

	# Recive encrypted aes file over socket, stores it decrypted
	# Input:	Filename (and location) to store the file
	# Return:	-
	def recv_file(self, path_to_file):
		try:
			encrypted_data = self.socket.recv(self.std_buffer)

			# Decrypt the data and store it in a file
			decrypted_data = self.AES_encryption.decrypt(encrypted_data)
			open(path_to_file, "w").write(decrypted_data)

		except Exception as e:
			print "[+] Failed to recive the encrypted file!"
			print "[-]", e

	# Close the socket
	# Input:	-
	# Return:	-
	def close(self):
		self.socket.close()

	# Prints debug information about the connection
	# Input:	-
	# Return:	-
	def debug(self):
		try:
			print "<=>" * 7 + " Debug information " + "<=>" *7
			print "<Information about the connection>"
			print "\tOwn IP address:", self.socket.getsockname()[0]
			print "\tOwn connection port:", self.socket.getsockname()[1]
			print "\tPartners IP address:", self.socket.getpeername()[0]
			print "\tPartners connection port:", self.socket.getpeername()[1]
			print "<Information about the connection>"
		except Exception as e:
			print "[+] Failed to print the debug information!"
			print "[-]", e

	# Close the socket
	# Input:	-
	# Return:	-
	def __del__(self):
		self.socket.close()

#############################################################################################
###				 			Socket - Encryption - Base Class    	 			      	  ###
###									With a socket										  ###
#############################################################################################


#############################################################################################
###				 	Socket - Diffie Hellman - AES-256-CBC encryption    	 	      	  ###
###									With a socket										  ###
#############################################################################################

# Class for an encrypted AES connection over tcp with Diffie Hellman key exchange
# Uses an external socket
class socket_encryption_dh_aes(base_aes_socket_encryption_class):

	# Initialize the class
	# Input:	Socket
	# Return:	-
	def __init__(self, sock):
		# Initialize with base class constructor
		base_aes_socket_encryption_class.__init__(self, sock)
		# Generate DH private key
		self.diffieHellmanKey = DiffieHellman()

	# Connect to server and start with DH key exchange and initiate AES encryption
	# Input:	-
	# Return:	-
	def client_key_exchange(self):
		try:
			# Recive partners Diffie Hellman key
			self.partnersDiffieHellmanKey = self.socket.recv(self.std_buffer)
			# Send personal Diffie Hellman key
			self.socket.send(str (self.diffieHellmanKey.publicKey))
			# Generate shared key (for the RSA connection)
			self.diffieHellmanKey.genKey(long (self.partnersDiffieHellmanKey))
			# Setup AES encryption
			self.AES_encryption = AESCipher(self.diffieHellmanKey.key)

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to server!"
			print "[-]", e
			self.socket.close()

	# Wait for clients to connect and start DH key exchange
	# Input:	-
	# Return:	-
	def server_key_exchange(self):
		try:
			# Send personal Diffie Hellman key
			self.socket.send(str (self.diffieHellmanKey.publicKey))
			# Recive partners Diffie Hellman key
			self.partnersDiffieHellmanKey = self.socket.recv(self.std_buffer)
			# Generate shared Diffie Hellman key
			self.diffieHellmanKey.genKey(long (self.partnersDiffieHellmanKey))
			# Initialize AES encryption
			self.AES_encryption = AESCipher(self.diffieHellmanKey.key)

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to client!"
			print "[-]", e
			self.socket.close()

	# Prints debug information about the key exchange
	# Input:	-
	# Return:	-
	def debug(self):
		try:
			base_aes_socket_encryption_class.debug(self)
			own_dh_pk = str (self.diffieHellmanKey.publicKey)
			partner_dh_pk =  str (self.partnersDiffieHellmanKey)
			char_per_line = 100

			print "\n<Information about the DH key exchange>"
			print "\t[+] Own Diffie Hellman public key:"
			for x in range(len(own_dh_pk)/char_per_line + 1):
				print "\t" + own_dh_pk[char_per_line * x : x * char_per_line + char_per_line]

			print "\n\t[+] Partners Diffie Hellman public key:"
			for x in range(len(partner_dh_pk)/char_per_line + 1):
				print "\t" + partner_dh_pk[char_per_line * x : x * char_per_line + char_per_line]

			print "\n\t[+] Shared Diffie Hellman key (AES):"
			print "\t" + hexlify(self.diffieHellmanKey.key)
			print "<Information about the DH key exchange>"
			print "<=>" * 7 + " Debug information " + "<=>" *7

		except Exception as e:
			print "[+] Failed to print the debug information!"
			print "[-]", e

#############################################################################################
###				 	Socket - Diffie Hellman - AES 256 CBC encryption    	 	      	  ###
###									With a socket										  ###
#############################################################################################


#############################################################################################
###							Socket - RSA - AES 256 CBC encryption       		          ###
###									With a socket										  ###
#############################################################################################

# Class for an encrypted AES connection over tcp with RSA key exchange
class socket_encryption_rsa_aes(base_aes_socket_encryption_class):

	# Initialize the class
	# Input:	Socket
	# Return:	-
	def __init__(self, sock):
		# Initialize with base class constructor
		base_aes_socket_encryption_class.__init__(self, sock)

	# Connect to server and start with RSA encryption
	# Input:	Partners RSA keyfile (public key)
	# Return:	-
	def client_key_exchange(self, partners_rsa_keyfile):
		try:
			# Set up the connection
			self.partner_rsa = RSA_ENC()
			self.partner_rsa.import_key(partners_rsa_keyfile)

			# Generate random AES key
			self.aes_key = Random.new().read(32)

			# Send encrypted AES key to the server
			self.encrypted_aes_key = self.partner_rsa.encrypt(self.aes_key)
			self.socket.send(self.encrypted_aes_key)

			# Initialize AES encrypted connection
			self.AES_encryption = AESCipher(self.aes_key)

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to server!"
			print "[-]", e
			self.socket.close()

	# Wait for clients to connect and start RSA encryption
	# Input:	Personal RSA keyfile (private key)
	# Return:	-
	def server_key_exchange(self, personal_rsa_keyfile):
		try:
			# Import RSA keyfile
			self.personal_rsa = RSA_ENC()
			self.personal_rsa.import_key(personal_rsa_keyfile)

			# Recive with RSA encrypted AES key
			self.encrypted_aes_key = self.socket.recv(self.std_buffer)
			# Decrypt AES key
			self.aes_key = self.personal_rsa.decrypt(self.encrypted_aes_key)

			# Initialize AES encrypted connection
			self.AES_encryption = AESCipher(self.aes_key)

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to client!"
			print "[-]", e
			self.socket.close()

	# Prints debug information about the key exchange
	# Input:	-
	# Return:	-
	def debug(self):
		try:
			# Print connection information
			base_aes_socket_encryption_class.debug(self)

			try:
				self.partner_rsa
				rsa_key = str (self.partner_rsa.show_public_key())
			except:
				rsa_key = str (self.personal_rsa.show_public_key())

			print "\n<Information about the used RSA key>"
			print "[+] Public RSA server key:"
			print rsa_key
			print "<Information about the used RSA key>"

			print "\n<Information about the used AES key>"
			print "[+] With RSA encrypted AES key"
			print self.encrypted_aes_key

			print "[+] Shared AES key:"
			print "\t" + hexlify(self.aes_key)

			print "<Information about the used AES key>"
			print "<=>" * 7 + " Debug information " + "<=>" *7

		except Exception as e:
			print "[+] Failed to print the debug data!"
			print "[-]", e

#############################################################################################
###							Socket - RSA - AES 256 CBC encryption       		          ###
###									With a socket										  ###
#############################################################################################


#############################################################################################
###						Socket - RSA - AES - Encryption and Authentication 		       	  ###
###									With a socket										  ###
#############################################################################################

# Class for an encrypted RSA - AES connection and Authentication
class socket_encryption_authentication_rsa_aes(base_aes_socket_encryption_class):

	# Initialize the class
	# Input:	Socket
	# Return:	-
	def __init__(self, sock):
		# Initialize with base class constructor
		base_aes_socket_encryption_class.__init__(self, sock)
		# Set No key found message
		self.msg_no_key_found = "NO PUBLIC KEY FILE FOUND"

	# XOR two strings together
	# Input:	String one
	# Input:	String twi
	# Return:	XOR'ed string
	def strxor (self, s0, s1):
	  l = [ chr ( ord (a) ^ ord (b) ) for a,b in zip (s0, s1) ]
	  return ''.join (l)

	# Connect to server and start with RSA encryption and authentication
	# Input:	Name of the file on the server in with my personal public key is stored
	# Input:	Personal RSA keyfile (private key)
	# Input:	Partners RSA keyfile (public key)
	# Return:	-
	def client_key_exchange(self, authentication_name, personal_rsa_keyfile, partner_rsa_keyfile):
		try:
			# Store RSA keyfiles for debuging and other methods
			self.personal_rsa = RSA_ENC()
			self.personal_rsa.import_key(personal_rsa_keyfile)
			self.partner_rsa = RSA_ENC()
			self.partner_rsa.import_key(partner_rsa_keyfile)
			self.authentication_name = authentication_name

			# Send encrypted authentication name (Server searches localy for a file with the same name -> should contain your public key)
			self.encrypted_authentication_name = self.partner_rsa.encrypt(self.authentication_name)
			self.socket.send(self.encrypted_authentication_name)

			# Server send an encrypted challange
			self.enc_server_side_key = self.socket.recv(self.std_buffer)
			if self.enc_server_side_key == self.msg_no_key_found:
				print "[+] Server found no public key file!"
				self.socket.close()
				exit(1)

			# Generate client side key
			self.client_side_key = Random.new().read(32)

			# Decrypt the challange with the private key
			self.server_side_key = self.personal_rsa.decrypt(self.enc_server_side_key)
			# Encrypt the cleartext challenge with the public key
			self.enc_client_side_key = self.partner_rsa.encrypt(self.client_side_key)
			# Send the new encrypted challange as response
			self.socket.send(self.enc_client_side_key)

			# Generate shared key
			self.shared_key = self.strxor(self.server_side_key, self.client_side_key)

			# Set aes encryption key
			self.AES_encryption = AESCipher(self.shared_key)

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to server!"
			print "[-]", e
			self.socket.close()

	# Wait for clients to connect and start RSA encryption and authentication
	# Input:	Personal RSA keyfile (private key)
	# Return:	-
	def server_key_exchange(self, personal_rsa_keyfile):
		try:
			# Store RSA keyfile for debuging and other methods
			self.personal_rsa = RSA_ENC()
			self.personal_rsa.import_key(personal_rsa_keyfile)

			# Recive encrypted filename which contains the public key of the user
			self.encrypted_authentication_name = self.socket.recv(self.std_buffer)
			self.authentication_name = self.personal_rsa.decrypt(self.encrypted_authentication_name)

			# Check if public key file exists
			if os.path.isfile(self.authentication_name):
				# Store authentication name
				self.partners_rsa = RSA_ENC()
				self.partners_rsa.import_key(self.authentication_name)

				# Create a random challange
				self.server_side_key = Random.new().read(32)

				# Encrypt the challange and send it
				self.enc_server_side_key = self.partners_rsa.encrypt(self.server_side_key)
				self.socket.send(self.enc_server_side_key)

				# Recive the response and decrypt it
				self.enc_client_side_key = self.socket.recv(self.std_buffer)
				self.client_side_key = self.personal_rsa.decrypt(self.enc_client_side_key)

				# Generate shared key
				self.shared_key = self.strxor(self.server_side_key, self.client_side_key)

				# Set the aes encryption key
				self.AES_encryption = AESCipher(self.shared_key)

			else:
				self.socket.send(self.msg_no_key_found)
				self.socket.close()
				print "[+] Could not import patners RSA public key!"

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to client!"
			print "[-]", e
			self.socket.close()

	# Prints debug information about the key exchange
	# Input:	-
	# Return:	-
	def debug(self):
		try:
			# Print connection information
			base_aes_socket_encryption_class.debug(self)

			print "\n<Information about the used RSA keys>"
			print "[+] Encrypted RSA server side key"
			print self.enc_server_side_key

			print "[+] RSA server side key (hex)"
			print hexlify(self.server_side_key)

			print "\n[+] Encrypted RSA client side key"
			print self.enc_client_side_key

			print "[+] RSA client side key (hex)"
			print hexlify(self.client_side_key)
			print "<Information about the used RSA keys>"

			print "\n<Information about the used AES key>"
			print "[+] RSA shared key (hex)"
			print hexlify(self.shared_key)
			print "<Information about the used AES key>"

			print "<=>" * 7 + " Debug information " + "<=>" *7

		except Exception as e:
			print "[+] Failed to print debug information!"
			print "[-]", e

#############################################################################################
###						Socket - RSA - AES - Encryption and Authentication 		       	  ###
###									With a socket										  ###
#############################################################################################


#############################################################################################
###				Socket - RSA - AES - Encryption and Authentication with DH      	      ###
###									With a socket										  ###
#############################################################################################

# Class for an encrypted RSA - AES connection and Authentication with Diffie Hellam for extra encryption
class socket_encryption_authentication_rsa_aes_dh(base_aes_socket_encryption_class):

	# Initialize the class
	# Input:	Socket
	# Return:	-
	def __init__(self, sock):
		# Initialize with base class constructor
		base_aes_socket_encryption_class.__init__(self, sock)
		# Generate DH private key
		self.diffieHellmanKey = DiffieHellman()
		# Set No key found message
		self.msg_no_key_found = "NO PUBLIC KEY FILE FOUND"

	# Connect to server and start with RSA encryption and authentication
	# Input:	Name of the file on the server in with my personal public key is stored
	# Input:	Personal RSA keyfile (private key)
	# Input:	Partners RSA keyfile (public key)
	# Return:	-
	def client_key_exchange(self,authentication_name, personal_rsa_keyfile, partners_rsa_keyfile):
		try:
			# Store RSA keyfiles for debuging and other methods
			self.personal_rsa = RSA_ENC()
			self.personal_rsa.import_key(personal_rsa_keyfile)
			self.partner_rsa = RSA_ENC()
			self.partner_rsa.import_key(partners_rsa_keyfile)

			# Name of the public key file stored localy on the server
			self.authentication_name = authentication_name

			# Send encrypted authentication name (Server searches localy for a file with the same name -> should contain your public key)
			self.encrypted_authentication_name = self.partner_rsa.encrypt(self.authentication_name)
			self.socket.send(self.encrypted_authentication_name)

			# Definition of the needed variables to hold the keys
			self.server_side_key_dh = ""
			self.enc_server_side_key_dh = ""
			self.client_side_key_dh = str (self.diffieHellmanKey.publicKey)
			self.enc_client_side_key_dh = ""

			# Recive encrypted server side Diffie Hellman key
			self.enc_server_side_key_dh = self.socket.recv(self.std_buffer)

			# Check if server finds public key file
			if self.enc_server_side_key_dh == self.msg_no_key_found:
				print "[+] Server found no public key file!"
				self.close_connection()
				exit(1)

			# Decrypt server side Diffie Hellman key
			self.server_side_key_dh = self.personal_rsa.decrypt_aes(str (self.enc_server_side_key_dh))

			# Send encrypted client side Diffie Hellman key
			self.enc_client_side_key_dh = self.partner_rsa.encrypt_aes(self.client_side_key_dh)
			self.socket.send(self.enc_client_side_key_dh)

			# Generate shared AES key
			self.diffieHellmanKey.genKey(long (self.server_side_key_dh))
			self.AES_encryption = AESCipher(self.diffieHellmanKey.key)

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to server!"
			print "[-]", e
			self.socket.close()

	# Wait for clients to connect and start RSA encryption and authentication
	# Input:	Personal RSA keyfile (private key)
	# Return:	-
	def server_key_exchange(self, personal_rsa_keyfile):
		try:
			# Import own RSA keyfile
			self.personal_rsa = RSA_ENC()
			self.personal_rsa.import_key(personal_rsa_keyfile)

			# Recive encrypted filename which contains the public key of the user
			self.encrypted_authentication_name = self.socket.recv(self.std_buffer)
			self.authentication_name =  self.personal_rsa.decrypt(self.encrypted_authentication_name)

			# Check if public key file exists
			if os.path.isfile(self.authentication_name):
				# Store authentication name
				self.partner_rsa = RSA_ENC()
				self.partner_rsa.import_key(self.authentication_name)


				# Definition of the needed variables to hold the keys
				self.bufferd_dh = ""
				self.server_side_key_dh = str (self.diffieHellmanKey.publicKey)
				self.enc_server_side_key_dh = ""
				self.client_side_key_dh = ""
				self.enc_client_side_key_dh = ""

				# Send encrypted server side Diffie Hellman key
				self.enc_server_side_key_dh = self.partner_rsa.encrypt_aes(str (self.server_side_key_dh))
				self.socket.send(self.enc_server_side_key_dh)

				# Recive encrypted client side Diffie Hellman key and decrypt it
				self.enc_client_side_key_dh = self.socket.recv(self.std_buffer)
				self.client_side_key_dh = self.personal_rsa.decrypt_aes(self.enc_client_side_key_dh)

				# Generate shared AES key
				self.diffieHellmanKey.genKey(long (self.client_side_key_dh))
				self.AES_encryption = AESCipher(self.diffieHellmanKey.key)

			else:
				self.socket.send(self.msg_no_key_found)
				self.socket.close()
				print "[+] Could not import patners RSA public key!"

		except KeyboardInterrupt:
			print "[+] Keyboard interrupt!"
			self.socket.close()
			exit(1)

		except Exception as e:
			print "[+] Failed to connect to client!"
			print "[-]", e
			self.socket.close()

	# Prints debug information about the key exchange
	# Input:	-
	# Return:	-
	def debug(self):
		try:
			# Print connection information
			base_aes_socket_encryption_class.debug(self)
			client_dh_pk = hexlify(self.client_side_key_dh)
			server_dh_pk = hexlify(self.server_side_key_dh)
			shared_key =  hexlify(self.diffieHellmanKey.key)
			char_per_line = 100

			print "\n<Information about the used RSA keys>"
			print "[+] Personal RSA public key"
			print self.personal_rsa.show_public_key()

			print "\n[+] Partners RSA public key"
			print self.partner_rsa.show_public_key()
			print "<Information about the used RSA keys>"

			print "\n<Information about the used DH key>"
			print "[+] Encrypted RSA server side Diffie Hellman key"
			print self.enc_server_side_key_dh

			print "\n[+] RSA server side Diffie Hellman key (hex)"
			for x in range(len(server_dh_pk)/char_per_line + 1):
				print "\t" + server_dh_pk[char_per_line * x : x * char_per_line + char_per_line]

			print "\n[+] Encrypted RSA client side Diffie Hellman key"
			print self.enc_client_side_key_dh

			print "\n[+] RSA client side Diffie Hellman key (hex)"
			for x in range(len(client_dh_pk)/char_per_line + 1):
				print "\t" + client_dh_pk[char_per_line * x : x * char_per_line + char_per_line]
			print "<Information about the used DH key>"

			print "\n<Information about the used AES key>"
			print "[+] Diffie Hellman aka AES shared key (hex)"
			print "\t" + shared_key
			print "<Information about the used AES key>"

			print "<=>" * 7 + " Debug information " + "<=>" *7

		except Exception as e:
			print "[+] Failed to print debug information!"
			print "[-]", e

#############################################################################################
###				Socket - RSA - AES - Encryption and Authentication with DH      	      ###
###									With a socket										  ###
#############################################################################################
